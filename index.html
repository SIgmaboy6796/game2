<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pew Shoot</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #333;
            color: white;
        }
        canvas {
            display: block;
        }
        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            border: 2px solid white;
            transform: translate(-50%, -50%);
            mix-blend-mode: difference;
        }
        .menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }
        .menu h2 {
            margin-top: 0;
        }
        .menu button {
            background-color: #444;
            color: white;
            border: 1px solid white;
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
        }
        .menu button:hover {
            background-color: #666;
        }
        #ammoCounter {
            position: absolute;
            bottom: 20px;
            right: 20px;
            font-size: 24px;
            font-family: monospace;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        #healthBar {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 200px;
            height: 20px;
            background-color: red;
            border: 2px solid white;
        }
        #health {
            width: 100%;
            height: 100%;
            background-color: green;
        }
        #lobby {
            display: none;
            padding: 20px;
        }
        #debugPanel {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0,0,0,0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            display: none;
            max-height: 90vh;
            overflow-y: auto;
            z-index: 1000;
            white-space: pre;
        }
        #playerList .list-group-item,
        #pendingConnectionList .list-group-item {
            color: black; /* Make lobby text readable */
        }
    </style>
</head>
<body>
    <div id="mainMenu" class="container text-center mt-5">
        <h1>Pew Shoot</h1>
        <div class="form-group">
            <label for="nametagInput">Enter Your Nametag:</label>
            <input type="text" class="form-control" id="nametagInput" placeholder="Player">
        </div>
        <button id="singlePlayerButton" class="btn btn-primary">Single Player</button>
        <button id="multiplayerButton" class="btn btn-success">Multiplayer</button>
    </div>

    <div id="lobby" class="container mt-5">
        <h2>Lobby</h2>
        <div id="host-controls">
            <button id="hostButton" class="btn btn-primary">Host Game</button>
            <div id="host-info" style="display: none;">
                <div id="pending-connections-container" class="mt-3" style="display: none;">
                    <h5>Incoming Connections:</h5>
                    <ul id="pendingConnectionList" class="list-group text-left"></ul>
                </div>
                <p>Your Host ID is: <strong id="hostIdDisplay"></strong></p>
                <button id="startGameButton" class="btn btn-success">Start Game</button>
            </div>
        </div>
        <hr>
        <div id="join-controls">
            <div class="form-group">
                <input type="text" class="form-control" id="peerIdInput" placeholder="Enter Host ID">
            </div>
            <button id="joinButton" class="btn btn-primary">Join Game</button>
        </div>
        <hr>
        <h3>Players in Lobby:</h3>
        <ul id="playerList" class="list-group">
        </ul>
    </div>

    <div id="game-ui" style="display: none;">
        <div id="ammoCounter"></div>
        <div id="healthBar">
            <div id="health"></div>
        </div>
        <div class="crosshair"></div>
        <div id="networkStatus" style="position: absolute; top: 10px; left: 50%; transform: translateX(-50%); font-size: 18px; background-color: rgba(0,0,0,0.5); padding: 5px 10px; border-radius: 5px; display: none;"></div>
        <div id="pauseMenu" class="menu" style="display: none;">
            <h2>Paused</h2>
            <button id="resumeButton">Resume</button>
            <button id="keybindsButton">Keybinds</button>
        </div>
        <div id="keybindsMenu" class="menu" style="display: none;">
            <h2>Keybinds</h2>
            <p>Move Forward: W</p>
            <p>Move Left: A</p>
            <p>Move Backward: S</p>
            <p>Move Right: D</p>
            <p>Jump: Space</p>
            <p>Pick Up Weapon: F</p>
            <p>Reload: R</p>
            <p>Shoot: Left Click</p>
            <p>Select Pistol: 1</p>
            <p>Select Shotgun: 2</p>
            <p>Select Rocket Launcher: 3</p>
            <button id="backButton">Back</button>
        </div>
    </div>

    <div id="debugPanel"></div>

    <script type="importmap">
        { "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
            "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js",
            "peerjs": "https://cdn.jsdelivr.net/npm/peerjs@1.5.2/+esm"
        } }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { init as initGame, players, getMyPlayerId } from '/game.js';
        import { initNetwork, connectToHost, sendData, getConnections, getMyId, setAsHost, acceptConnection, declineConnection } from '/network.js';
        import { logPlayers, logObjects, logConnections } from '/debug.js';

        const mainMenu = document.getElementById('mainMenu');
        const lobby = document.getElementById('lobby');
        const gameUi = document.getElementById('game-ui');

        const nametagInput = document.getElementById('nametagInput');
        const singlePlayerButton = document.getElementById('singlePlayerButton');
        const multiplayerButton = document.getElementById('multiplayerButton');

        const hostButton = document.getElementById('hostButton');
        const hostInfo = document.getElementById('host-info');
        const hostIdDisplay = document.getElementById('hostIdDisplay');
        const startGameButton = document.getElementById('startGameButton');

        const joinButton = document.getElementById('joinButton');
        const peerIdInput = document.getElementById('peerIdInput');

        const playerList = document.getElementById('playerList');
        const networkStatus = document.getElementById('networkStatus');
        const debugPanel = document.getElementById('debugPanel');

        const pendingConnectionsContainer = document.getElementById('pending-connections-container');
        const pendingConnectionList = document.getElementById('pendingConnectionList');

        let nametag = 'Player';
        let isHost = false;
        let isMultiplayer = false;
        let gameScene = null; // Will hold the THREE.Scene instance
        let shootHandler = null; // Will hold the handleShoot function
        let gameFont = null; // Will hold the loaded font
        const playerCreateQueue = []; // Queue for players that arrive before the game scene is ready

        function showNetworkStatus(message, isError = false) {
            networkStatus.textContent = message;
            networkStatus.style.backgroundColor = isError ? 'red' : 'rgba(0,0,0,0.5)';
            networkStatus.style.display = 'block';
            setTimeout(() => networkStatus.style.display = 'none', 3000);
        }

        function updatePlayerList(players) {
            playerList.innerHTML = '';
            players.forEach(player => {
                const li = document.createElement('li');
                li.className = 'list-group-item';
                li.textContent = player.nametag;
                playerList.appendChild(li);
            });
        }

        function launchSinglePlayerGame() {
            isMultiplayer = false;
            nametag = nametagInput.value.trim() || 'Player';
            mainMenu.style.display = 'none';
            lobby.style.display = 'none';
            gameUi.style.display = 'block';
            initGame(nametag, false);
        }

        function initLobby() {
            nametag = nametagInput.value.trim() || `Player-${Math.floor(1000 + Math.random() * 9000)}`;
            mainMenu.style.display = 'none';
            lobby.style.display = 'block';
            // Initialize network as soon as we enter the lobby.
            // This makes us ready to either host or join.
            initNetwork(nametag, (id) => {
                // This callback provides the peer ID once ready.
                // If we decide to host, we'll use this ID.
                hostIdDisplay.textContent = id;
            });
        }

        function launchMultiplayerGame() {
            isMultiplayer = true;
            mainMenu.style.display = 'none';
            lobby.style.display = 'none';
            gameUi.style.display = 'block';
            initGame(nametag, true, isHost);
        }

        singlePlayerButton.addEventListener('click', launchSinglePlayerGame);

        multiplayerButton.addEventListener('click', initLobby);

        hostButton.addEventListener('click', () => {
            console.log('[UI] Host button clicked.');
            isHost = true;
            setAsHost(); // Tell the network layer that we are the host.
            hostInfo.style.display = 'block';
            pendingConnectionsContainer.style.display = 'block';
            hostButton.style.display = 'none';
            document.getElementById('join-controls').style.display = 'none'; // Hide join controls for host
            updatePlayerList([{ nametag }]);
        });

        joinButton.addEventListener('click', () => {
            console.log('[UI] Join button clicked.');
            const hostId = peerIdInput.value.trim();
            if (hostId) {
                joinButton.disabled = true;
                hostButton.disabled = true;
                peerIdInput.disabled = true;
                showNetworkStatus(`Connecting to ${hostId}...`);
                connectToHost(hostId);
            } else {
                showNetworkStatus('Please enter a valid Host ID.', true);
            }
        });

        startGameButton.addEventListener('click', () => {
            console.log('[UI] Start Game button clicked by host.');
            // Notify other players to start the game
            sendData({ type: 'start-game' });
            launchMultiplayerGame();
        });

        pendingConnectionList.addEventListener('click', (event) => {
            const target = event.target;
            const peerId = target.dataset.peerId;
            if (!peerId) return;

            if (target.classList.contains('accept-btn')) {
                console.log(`[UI] Accepting connection from ${peerId}`);
                acceptConnection(peerId);
            } else if (target.classList.contains('decline-btn')) {
                console.log(`[UI] Declining connection from ${peerId}`);
                declineConnection(peerId);
            }
            document.getElementById(`pending-${peerId}`).remove();
        });

        // --- GLOBAL NETWORKING LISTENERS ---
        // These are set up once on page load to prevent race conditions.

        function createPlayer(peerId, nametag) {
            // This function is called by network events.
            // It needs access to the game's scene, which is only available after initGame.
            if (!gameScene || !gameFont) {
                console.log(`[UI] Scene not ready. Queuing creation of player ${peerId}`);
                playerCreateQueue.push({ peerId, nametag });
                return;
            }
            if (!gameFont) {
                console.error("Attempted to create player nametag before font was loaded.");
                // We can still create the player mesh, just without the nametag.
            }
            console.log(`Creating player for ${peerId} (${nametag})`);
            const playerMesh = new THREE.Mesh(new THREE.BoxGeometry(1, 1.8, 1), new THREE.MeshStandardMaterial({ color: 0xff0000 }));
            gameScene.add(playerMesh);

            let nametagMesh = null; // Initialize as null
            if (gameFont && gameScene) { // Ensure both scene and font are ready
                const textGeometry = new TextGeometry(nametag, { font: gameFont, size: 0.2, height: 0.02 });
                const textMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
                nametagMesh = new THREE.Mesh(textGeometry, textMaterial);
                nametagMesh.geometry.center();
                gameScene.add(nametagMesh);
            } else {
                console.warn(`[UI] gameFont not ready when creating player ${peerId}. Nametag will be missing.`);
            }

            players[peerId] = { mesh: playerMesh, nametagMesh: nametagMesh, nametag: nametag, position: new THREE.Vector3(), quaternion: new THREE.Quaternion() };
        }

        window.addEventListener('game-initialized', (e) => {
            // The game.js file will dispatch this event when it's ready.
            gameScene = e.detail.scene;
            shootHandler = e.detail.handleShoot;
            gameFont = e.detail.font; // Make sure game.js dispatches the font

            // Now that the game is ready, process any players that were queued.
            console.log(`[UI] Game initialized. Processing ${playerCreateQueue.length} queued players.`);
            while (playerCreateQueue.length > 0) {
                const playerData = playerCreateQueue.shift();
                createPlayer(playerData.peerId, playerData.nametag);
            }
        });

        window.addEventListener('pending-connection', (event) => {
            const { peerId, nametag } = event.detail;
            console.log(`[UI] "pending-connection" event for ${peerId} (${nametag})`);
            const li = document.createElement('li');
            li.id = `pending-${peerId}`;
            li.className = 'list-group-item d-flex justify-content-between align-items-center';
            li.innerHTML = `
                <span>${nametag} (${peerId})</span>
                <div>
                    <button class="btn btn-sm btn-success accept-btn" data-peer-id="${peerId}">Accept</button>
                    <button class="btn btn-sm btn-danger decline-btn" data-peer-id="${peerId}">Decline</button>
                </div>`;
            pendingConnectionList.appendChild(li);
        });

        window.addEventListener('data-received', (event) => {
            console.log('[UI] "data-received" event:', event.detail);
            const { peerId, data } = event.detail;
            if (!data.type) return;

            if (data.type === 'state') {
                const player = players[peerId];
                if (player) player.position.copy(data.position);
            } else if (data.type === 'shoot') {
                if (shootHandler) shootHandler(new THREE.Vector3().copy(data.direction), data.weapon);
            } else if (data.type === 'new-player') {
                if (!players[data.peerId]) {
                    createPlayer(data.peerId, data.nametag);
                }
            } else if (data.type === 'welcome') {
                // This is for the newly joined client
                data.players.forEach(p => {
                    // Don't create a player for ourselves. getMyId() is from network.js
                    if (p.peerId !== getMyId() && !players[p.peerId]) {
                        createPlayer(p.peerId, p.nametag);
                    }
                });
            }
            else if (data.type === 'player-list') { // Client receives this
                // This is for clients already in the lobby when another joins/leaves
                dispatchNetworkEvent('player-list-updated', { players: data.players });
            }
            else if (data.type === 'start-game') {
                // This is for clients when the host starts the game
                dispatchNetworkEvent('game-started');
            }

        });

        window.addEventListener('player-list-updated', (event) => {
            console.log('[UI] "player-list-updated" event:', event.detail);
            updatePlayerList(event.detail.players);
            // If I'm a client and I just received a player list, it means I've successfully joined the lobby.
            if (!isHost && lobby.style.display === 'block') {
                // Hide join controls and show that we are waiting for the host.
                document.getElementById('join-controls').style.display = 'none';
                hostButton.style.display = 'none';
                hostInfo.style.display = 'block';
                hostInfo.innerHTML = '<p>Connected to lobby. Waiting for host to start...</p>';
                startGameButton.style.display = 'none'; // Only host can start
            }
            if (!isHost) startGameButton.style.display = 'none';
        });

        window.addEventListener('game-started', () => {
            console.log('[UI] "game-started" event received. Launching multiplayer game.');
            launchMultiplayerGame();
        });

        window.addEventListener('player-disconnected', (event) => {
            console.log('[UI] "player-disconnected" event:', event.detail);
            const { peerId } = event.detail;
            if (players[peerId] && players[peerId].nametagMesh && gameScene) {
                gameScene.remove(players[peerId].nametagMesh);
            }
            if (players[peerId] && gameScene) {
                gameScene.remove(players[peerId].mesh);
                delete players[peerId];
            }
            showNetworkStatus(`Player ${event.detail.peerId} disconnected.`, true);
            if (isHost && lobby.style.display === 'block') {
                // Host needs to update everyone's player list
                const connections = getConnections();
                const players = connections.map(c => ({ nametag: c.metadata.nametag }));
                players.push({ nametag });
                sendData({ type: 'player-list', players });
                updatePlayerList(players);
            }
        });

        window.addEventListener('connection-open', (event) => {
            console.log('[UI] "connection-open" event:', event.detail);
            showNetworkStatus(`Connected to ${event.detail.peerId}!`);
        });

        window.addEventListener('connection-error', (event) => {
            console.error('[UI] "connection-error" event:', event.detail);
            showNetworkStatus(`Error: ${event.detail.error.type || 'Connection failed'}`, true);
        });

        // --- DEBUGGING ---
        let debugVisible = false;
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Backquote') { // ` key
                debugVisible = !debugVisible;
                debugPanel.style.display = debugVisible ? 'block' : 'none';
                if (debugVisible) {
                    updateDebugPanel();
                }
            }
        });

        function updateDebugPanel() {
            debugPanel.textContent = `${logPlayers(true)}\n\n${logObjects(true)}\n\n${logConnections(true)}`;
            if (debugVisible) requestAnimationFrame(updateDebugPanel);
        }
    </script>
</body>
</html>