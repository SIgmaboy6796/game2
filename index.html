<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Call-Of-Zdenek</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #00aeff;
            --secondary-color: #ff00ff;
            --background-color: #12121c;
            --surface-color: rgba(20, 20, 30, 0.85);
            --text-color: #e0e0e0;
            --glow-color: rgba(0, 174, 255, 0.7);
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--background-color);
            color: var(--text-color);
            font-family: 'Roboto', sans-serif;
        }

        canvas {
            display: block;
        }

        /* --- UI Containers --- */
        .ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: radial-gradient(ellipse at center, rgba(18, 18, 28, 0.8) 0%, rgba(18, 18, 28, 1) 100%);
            backdrop-filter: blur(5px);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease, visibility 0.5s ease;
        }

        .ui-container.active {
            opacity: 1;
            visibility: visible;
        }

        /* --- Main Menu --- */
        #mainMenu {
            justify-content: space-between;
        }

        .main-menu-header {
            width: 100%;
            padding: 2rem;
            text-align: center;
            background: linear-gradient(to bottom, var(--surface-color), transparent);
        }

        .main-menu-center {
            display: flex;
            flex-direction: column;
        }

        .game-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 5rem;
            font-weight: 700;
            color: var(--primary-color);
            text-shadow: 0 0 10px var(--glow-color), 0 0 20px var(--glow-color);
            letter-spacing: 2px;
        }

        .main-menu-footer {
            width: 100%;
            padding: 2rem;
            display: flex;
            justify-content: center;
            align-items: center;
            background: linear-gradient(to top, var(--surface-color), transparent);
        }

        /* --- Buttons & Inputs --- */
        .btn-glow {
            background-color: transparent;
            border: 2px solid var(--primary-color);
            color: var(--primary-color);
            padding: 12px 28px;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            transition: all 0.3s ease;
            box-shadow: 0 0 5px var(--glow-color), inset 0 0 5px var(--glow-color);
            margin: 10px;
        }

        .btn-glow:hover, .btn-glow:focus {
            background-color: var(--primary-color);
            color: var(--background-color);
            box-shadow: 0 0 15px var(--glow-color), 0 0 30px var(--glow-color), inset 0 0 5px white;
            transform: scale(1.05);
        }

        .input-glow {
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid var(--primary-color);
            color: var(--text-color);
            padding: 12px 20px;
            box-shadow: 0 0 5px var(--glow-color);
            transition: box-shadow 0.3s ease;
        }

        .input-glow:focus {
            background-color: rgba(0, 0, 0, 0.7);
            box-shadow: 0 0 15px var(--glow-color);
            outline: none;
        }
        
        .keybind-list {
            list-style: none;
            padding: 0;
        }

        .keybind-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            border-bottom: 1px solid rgba(0, 174, 255, 0.2);
        }
        .keybind-item:last-child {
            border-bottom: none;
        }

        /* --- Lobby & Settings --- */
        .menu-panel {
            background-color: var(--surface-color);
            padding: 2rem 3rem;
            border-radius: 10px;
            border: 1px solid var(--primary-color);
            box-shadow: 0 0 20px var(--glow-color);
            width: 90%;
            max-width: 800px;
            max-height: 80vh;
            display: flex;
            overflow-y: auto;
            flex-direction: column;
        }
        
        #keybinds-panel {
            display: none; /* Hidden by default */
            flex-direction: column;
            text-align: left;
        }

        .menu-panel h2 {
            font-family: 'Orbitron', sans-serif;
            color: var(--primary-color);
            text-align: center;
            margin-bottom: 1.5rem;
        }

        #server-list-container {
            flex-grow: 1;
            overflow-y: auto;
            border: 1px solid #333;
            background-color: rgba(0,0,0,0.3);
        }

        .server-item {
            background-color: transparent;
            border-color: #333;
            color: var(--text-color);
            transition: background-color 0.2s ease;
        }

        .server-item:hover {
            background-color: rgba(0, 174, 255, 0.2);
            color: white;
        }

        /* --- In-Game UI --- */
        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            background-color: white;
            transform: translate(-50%, -50%);
            mix-blend-mode: difference;
            pointer-events: none;
        }

        #ammoCounter {
            position: absolute;
            bottom: 20px;
            right: 20px;
            font-size: 2.5rem;
            font-family: 'Orbitron', sans-serif;
            color: var(--primary-color);
            text-shadow: 0 0 5px var(--glow-color), 0 0 10px var(--glow-color);
        }

        #healthBar {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 200px;
            height: 20px;
            background-color: rgba(255, 0, 0, 0.3);
            border: 1px solid var(--primary-color);
        }

        #health {
            width: 100%;
            height: 100%;
            background-color: var(--primary-color);
            transition: width 0.5s ease;
        }

        #pauseMenu, #keybindsMenu {
            background-color: var(--surface-color);
            padding: 40px;
            border-radius: 10px;
            border: 1px solid var(--primary-color);
            box-shadow: 0 0 20px var(--glow-color);
            text-align: center;
            max-height: 80vh; /* Add max-height */
            overflow-y: auto; /* Add scroll for overflow */
        }

        #pauseMenu {
            max-height: initial; /* Pause menu doesn't need to scroll */
            overflow-y: initial;
        }

        #pauseMenu h2, #keybindsMenu h2 {
            font-family: 'Orbitron', sans-serif;
            color: var(--primary-color);
            margin-bottom: 1.5rem;
        }
    </style>
</head>
<body>
    <!-- Main Menu -->
    <div id="mainMenu" class="ui-container active">
        <div class="main-menu-header">
            <h1 class="game-title">Call-Of-Zdenek</h1>
        </div>
        <div class="main-menu-center">
            <button id="singlePlayerButton" class="btn btn-glow btn-lg">Single Player</button>
            <button id="multiplayerButton" class="btn btn-glow btn-lg">Multiplayer</button>
        </div>
        <div class="main-menu-footer">
            <input type="text" class="form-control input-glow mr-3" id="nametagInput" placeholder="Enter Nametag...">
            <button id="settingsButton" class="btn btn-glow">Settings</button>
        </div>
    </div>

    <!-- Multiplayer Lobby -->
    <div id="lobby" class="ui-container">
        <div class="menu-panel">
            <!-- Join View -->
            <div id="join-view">
                <div class="d-flex justify-content-between align-items-center mb-3">
                    <h2>Server Browser</h2>
                    <div>
                        <button id="hostChoiceButton" class="btn btn-glow">Host New Game</button>
                        <button id="backToMainMenuFromLobby" class="btn btn-secondary">Back</button>
                    </div>
                </div>
                <div id="server-list-container" class="list-group mb-3">
                    <div id="no-servers-message" class="list-group-item list-group-item-dark text-dark">Searching for active games...</div>
                </div>
                <div class="input-group">
                    <input type="text" id="joinIdInput" class="form-control input-glow" placeholder="...or enter a Room Code to join">
                    <div class="input-group-append">
                        <button id="connectToHostButton" class="btn btn-glow">Join</button>
                    </div>
                </div>
            </div>

            <!-- Host Lobby View -->
            <div id="host-lobby" style="display: none;">
                <h2>Hosting Game</h2>
                <p>Share this Room Code with your friends:</p>
                <div class="input-group mb-3">
                    <input type="text" id="hostIdDisplay" class="form-control input-glow" readonly placeholder="Generating Code...">
                    <div class="input-group-append">
                        <button class="btn btn-glow" id="copyIdButton">Copy</button>
                    </div>
                </div>
                <h4>Players in Lobby:</h4>
                <ul id="playerList" class="list-group mb-3 bg-transparent"></ul>
                <div class="mt-auto text-center">
                    <button id="startGameButton" class="btn btn-glow btn-success">Start Game</button>
                    <button id="cancelHostButton" class="btn btn-secondary mt-2">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Settings Menu -->
    <div id="settings-menu" class="ui-container">
        <div class="menu-panel text-center">
            <h2>Settings</h2>
            <div id="main-settings-panel">
                <button id="openKeybindsButton" class="btn btn-glow">Keybinds</button>
                <button id="backToMainMenuFromSettings" class="btn btn-glow mt-4">Back</button>
            </div>
            <div id="keybinds-panel"></div>
        </div>
    </div>

    <!-- In-Game UI -->
    <div id="game-ui" style="display: none;">
        <div id="ammoCounter"></div>
        <div id="healthBar">
            <div id="health"></div>
        </div>
        <div class="crosshair"></div>
        <div id="networkStatus" style="position: absolute; top: 10px; left: 50%; transform: translateX(-50%); font-size: 16px; background-color: var(--surface-color); padding: 8px 15px; border-radius: 5px; display: none; border: 1px solid var(--primary-color);"></div>
        <div id="pauseMenu" style="display: none;">
            <h2>Paused</h2>
            <button id="resumeButton" class="btn btn-glow">Resume</button>
            <button id="keybindsButton" class="btn btn-glow">Keybinds</button>
        </div>
        <div id="keybindsMenu" style="display: none;">
            <!-- This will be populated by JavaScript -->
        </div>
    </div>

    <script type="importmap">
        { "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
            "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js",
            "peerjs": "https://cdn.jsdelivr.net/npm/peerjs@1.5.2/+esm"
        } }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { init as initGame, players } from '/game.js';
        import { loadKeybinds, saveKeybind, getKeybinds, getKeyDisplayName } from '/keybinds.js';
        import { initNetwork, connectToHost, sendData, getConnections, getMyId, setAsHost, hostGame, getHostPeerId } from '/network.js';

        // --- UI Element Declarations ---
        const mainMenu = document.getElementById('mainMenu');
        const lobby = document.getElementById('lobby');
        const gameUi = document.getElementById('game-ui');
        const singlePlayerButton = document.getElementById('singlePlayerButton');
        const multiplayerButton = document.getElementById('multiplayerButton');
        const settingsButton = document.getElementById('settingsButton');
        const openKeybindsButton = document.getElementById('openKeybindsButton');
        const mainSettingsPanel = document.getElementById('main-settings-panel');
        const keybindsPanel = document.getElementById('keybinds-panel');
        const settingsMenu = document.getElementById('settings-menu');
        const nametagInput = document.getElementById('nametagInput'); nametagInput.value = `Player-${Math.floor(1000 + Math.random() * 9000)}`;
        const joinView = document.getElementById('join-view');
        const hostLobby = document.getElementById('host-lobby');
        const cancelHostButton = document.getElementById('cancelHostButton');
        const playerList = document.getElementById('playerList');
        const hostChoiceButton = document.getElementById('hostChoiceButton');
        const hostIdDisplay = document.getElementById('hostIdDisplay');
        const copyIdButton = document.getElementById('copyIdButton'); // This was missing a declaration
        const startGameButton = document.getElementById('startGameButton');
        const joinIdInput = document.getElementById('joinIdInput');
        const connectToHostButton = document.getElementById('connectToHostButton');
        const noServersMessage = document.getElementById('no-servers-message');
        const serverListContainer = document.getElementById('server-list-container');
        const networkStatus = document.getElementById('networkStatus');
        const resumeButton = document.getElementById('resumeButton');
        const keybindsButton = document.getElementById('keybindsButton');
        const backButton = document.getElementById('backButton');
        const pauseMenu = document.getElementById('pauseMenu');
        const keybindsMenu = document.getElementById('keybindsMenu');

        // Pause menu elements
        let controls; // This will be set in initGame
        let isPaused = false;

        let nametag = 'Player';
        let isHost = false;
        let myPeerId = null; // Variable to store our own peer ID
        let isMultiplayer = false;
        let gameScene = null; // Will hold the THREE.Scene instance
        let shootHandler = null; // Will hold the handleShoot function
        let gameFont = null; // Will hold the loaded font
        const playerCreateQueue = []; // Queue for players that arrive before the game scene is ready
        let serverList = {}; // { roomCode: peerId }

        // --- UI View Management ---
        const allViews = [mainMenu, lobby, settingsMenu, gameUi];
        loadKeybinds(); // Load keybinds on startup
        function showView(viewToShow) {
            allViews.forEach(view => {
                if (view === viewToShow) {
                    view.classList.add('active');
                } else {
                    view.classList.remove('active');
                }
            });
        }

        // --- INITIALIZATION ---
        populateKeybindsMenu();
        populateInGameKeybindsMenu();
        setupGlobalNetworkListeners();

        function showNetworkStatus(message, isError = false) {
            networkStatus.textContent = message;
            networkStatus.style.backgroundColor = isError ? 'red' : 'rgba(0,0,0,0.5)';
            networkStatus.style.display = 'block';
            setTimeout(() => networkStatus.style.display = 'none', 3000);
        }

        function updatePlayerList(players) {
            playerList.innerHTML = '';
            players.forEach(player => {
                const li = document.createElement('li');
                li.className = 'list-group-item';
                li.textContent = player.nametag;
                playerList.appendChild(li);
            });
        }

        function updateServerListUI() {
            serverListContainer.innerHTML = '';
            const rooms = Object.keys(serverList);
            if (rooms.length === 0) {
                serverListContainer.appendChild(noServersMessage);
                noServersMessage.textContent = 'No active games found. Why not host one?';
            } else {
                rooms.forEach(roomCode => {
                    const peerId = serverList[roomCode];
                    const serverItem = document.createElement('a');
                    serverItem.href = '#';
                    serverItem.className = 'list-group-item list-group-item-action server-item';
                    // For now, just show the room code. You could add more info like player count later.
                    serverItem.textContent = `Game Room: ${roomCode}`;
                    serverItem.onclick = (e) => {
                        e.preventDefault();
                        joinIdInput.value = roomCode;
                        connectToHostButton.click();
                    };
                    serverListContainer.appendChild(serverItem);
                });
            }
        }

        function initLobby() {
            nametag = nametagInput.value.trim() || `Player-${Math.floor(1000 + Math.random() * 9000)}`;
            showView(lobby);
            initNetwork(nametag);
        }

        function launchMultiplayerGame() {
            isMultiplayer = true;
            showView(null); // Hide all UI containers
            gameUi.style.display = 'block';
            initGame(nametag, true, isHost);
        }

        function launchSinglePlayerGame() {
            isMultiplayer = false;
            nametag = nametagInput.value.trim() || 'Player';
            showView(null);
            gameUi.style.display = 'block';
            initGame(nametag, false);
        }

        // --- UI Event Listeners ---

        singlePlayerButton.addEventListener('click', launchSinglePlayerGame);

        multiplayerButton.addEventListener('click', () => {
            initLobby();
        });

        settingsButton.addEventListener('click', () => {
            showView(settingsMenu);
        });

        openKeybindsButton.addEventListener('click', () => {
            mainSettingsPanel.style.display = 'none';
            keybindsPanel.style.display = 'flex';
        });

        document.getElementById('backToMainMenuFromSettings').addEventListener('click', () => {
            showView(mainMenu);
            mainSettingsPanel.style.display = 'block';
            keybindsPanel.style.display = 'none';
        });
        
        document.getElementById('backToMainMenuFromLobby').addEventListener('click', () => {
            // TODO: Disconnect from peer/matchmaking if necessary
            showView(mainMenu);
            // Reset lobby views
            joinView.style.display = 'block';
            hostLobby.style.display = 'none';
        });

        hostChoiceButton.addEventListener('click', () => {
            console.log('[UI] Host button clicked.');
            isHost = true;
            joinView.style.display = 'none'; // Hide join view
            setAsHost(); // Tell the network layer that we are the host.
            hostLobby.style.display = 'block'; 
            showNetworkStatus('Requesting room code from server...');
            // If peer is ready, host immediately. Otherwise, the 'peer-ready' event will trigger it.
            if (myPeerId) hostGame(myPeerId);
            updatePlayerList([{ nametag: nametagInput.value.trim() || 'Player' }]);
        });

        cancelHostButton.addEventListener('click', () => {
            hostLobby.style.display = 'none';
            joinView.style.display = 'block';
            // TODO: Tell matchmaking server to close the room
        });

        copyIdButton.addEventListener('click', () => {
            navigator.clipboard.writeText(hostIdDisplay.value).then(() => {
                showNetworkStatus('Room Code copied to clipboard!');
            });
        });

        connectToHostButton.addEventListener('click', () => {
            const roomCode = joinIdInput.value.trim().toUpperCase();
            if (roomCode && roomCode.length === 4) {
                showNetworkStatus(`Looking up room ${roomCode}...`);
                getHostPeerId(roomCode); // Ask matchmaking server for the host's real PeerJS ID
            } else {
                showNetworkStatus('Please enter a valid 4-letter room code.', true);
            }
        });

        startGameButton.addEventListener('click', () => {
            console.log('[UI] Start Game button clicked by host.');
            sendData({ type: 'start-game' });
            launchMultiplayerGame();
        });

        // --- Pause Menu Logic ---
        window.addEventListener('game-controls-ready', (e) => {
            controls = e.detail.controls;

            controls.addEventListener('lock', () => {
                isPaused = false;
                pauseMenu.style.display = 'none';
                keybindsMenu.style.display = 'none';
            });

            controls.addEventListener('unlock', () => {
                isPaused = true;
                pauseMenu.style.display = 'block';
            });
        });

        resumeButton.addEventListener('click', () => {
            if (controls) controls.lock();
        });

        keybindsButton.addEventListener('click', () => {
            pauseMenu.style.display = 'none';
            keybindsMenu.style.display = 'block';
        });

        backButton.addEventListener('click', () => {
            keybindsMenu.style.display = 'none';
            pauseMenu.style.display = 'block';
        });

        // --- Keybinds UI Logic ---
        function populateKeybindsMenu() {
            // This function now populates the MAIN MENU keybinds panel
            const keybinds = getKeybinds();
            const actions = {
                moveForward: 'Move Forward',
                moveBackward: 'Move Backward',
                moveLeft: 'Move Left',
                moveRight: 'Move Right',
                jump: 'Jump',
                reload: 'Reload',
                pickup: 'Pick Up Weapon',
                shoot: 'Shoot',
                scope: 'Aim Down Sights',
                weapon1: 'Weapon 1 (Pistol)',
                weapon2: 'Weapon 2 (Shotgun)',
                weapon3: 'Weapon 3 (Rocket Launcher)',
            };

            let html = `<h2>Keybinds</h2><ul class="keybind-list">`;
            for (const action in actions) {
                const key = keybinds[action];
                html += `<li class="keybind-item">
                           <span>${actions[action]}</span>
                           <button class="btn btn-secondary keybind-button" data-action="${action}">${getKeyDisplayName(key)}</button>
                         </li>`;
            }
            html += `</ul><button id="backToMainSettings" class="btn btn-glow mt-3">Back</button>`;
            keybindsPanel.innerHTML = html;

            document.getElementById('backToMainSettings').addEventListener('click', () => {
                keybindsPanel.style.display = 'none';
                mainSettingsPanel.style.display = 'block';
            });

            document.querySelectorAll('.keybind-button').forEach(button => {
                button.addEventListener('click', () => {
                    const action = button.dataset.action;
                    button.textContent = 'Press any key...';
                    button.disabled = true;

                    function onKeybindSet(event) {
                        // Prevent binding Escape
                        if (event.code === 'Escape') {
                            button.textContent = getKeyDisplayName(keybinds[action]);
                            button.disabled = false;
                            window.removeEventListener('keydown', onKeybindSet);
                            return;
                        }
                        // Handle mouse clicks
                        if (event.type === 'mousedown') {
                            saveKeybind(action, `MouseButton${event.button}`);
                            button.textContent = getKeyDisplayName(`MouseButton${event.button}`);
                            button.disabled = false;
                            window.removeEventListener('keydown', onKeybindSet);
                            return;
                        }
                        saveKeybind(action, event.code);
                        button.textContent = getKeyDisplayName(event.code);
                        button.disabled = false;
                        window.removeEventListener('keydown', onKeybindSet);
                        loadKeybinds(); // Reload keybinds in the game logic
                    }

                    window.addEventListener('mousedown', onKeybindSet, { once: true });
                    window.addEventListener('keydown', onKeybindSet, { once: true });
                });
            });
        }

        function populateInGameKeybindsMenu() {
            const keybinds = getKeybinds();
            const actions = {
                moveForward: 'Move Forward',
                moveBackward: 'Move Backward',
                moveLeft: 'Move Left',
                moveRight: 'Move Right',
                jump: 'Jump',
                reload: 'Reload',
                pickup: 'Pick Up Weapon',
                shoot: 'Shoot',
                scope: 'Aim Down Sights',
                weapon1: 'Weapon 1 (Pistol)',
                weapon2: 'Weapon 2 (Shotgun)',
                weapon3: 'Weapon 3 (Rocket Launcher)',
            };

            let html = `<h2>Keybinds</h2><ul class="keybind-list">`;
            for (const action in actions) {
                const key = keybinds[action];
                html += `<li class="keybind-item">
                           <span>${actions[action]}</span>
                           <button class="btn btn-secondary keybind-button-ingame" data-action="${action}">${getKeyDisplayName(key)}</button>
                         </li>`;
            }
            html += `</ul><button id="backButton" class="btn btn-glow mt-3">Back</button>`;
            keybindsMenu.innerHTML = html;

            // The back button is already handled by an existing listener, so we don't need to re-add it.

            document.querySelectorAll('.keybind-button-ingame').forEach(button => {
                button.addEventListener('click', () => {
                    const action = button.dataset.action;
                    button.textContent = 'Press any key...';
                    button.disabled = true;

                    function onKeybindSet(event) {
                        // Prevent binding Escape
                        if (event.code === 'Escape') {
                            button.textContent = getKeyDisplayName(getKeybinds()[action]);
                            button.disabled = false;
                            window.removeEventListener('keydown', onKeybindSet);
                            return;
                        }
                        // Handle mouse clicks
                        if (event.type === 'mousedown') {
                            saveKeybind(action, `MouseButton${event.button}`);
                            button.textContent = getKeyDisplayName(`MouseButton${event.button}`);
                            button.disabled = false;
                            window.removeEventListener('keydown', onKeybindSet);
                            return;
                        }
                        saveKeybind(action, event.code);
                        button.textContent = getKeyDisplayName(event.code);
                        button.disabled = false;
                        window.removeEventListener('keydown', onKeybindSet);
                        loadKeybinds(); // Reload keybinds in the game logic
                    }

                    window.addEventListener('mousedown', onKeybindSet, { once: true });
                    window.addEventListener('keydown', onKeybindSet, { once: true });
                });
            });
        }

        // --- GLOBAL EVENT LISTENERS ---
        // Centralized setup for all network and game-related events.

        function createPlayer(peerId, nametag) {
            // This function is called by network events.
            // It needs access to the game's scene, which is only available after initGame.
            if (!gameScene || !gameFont) {
                console.log(`[UI] Scene not ready. Queuing creation of player ${peerId}`);
                playerCreateQueue.push({ peerId, nametag });
                return;
            }
            if (!gameFont) {
                console.error("Attempted to create player nametag before font was loaded.");
                // We can still create the player mesh, just without the nametag.
            }
            console.log(`Creating player for ${peerId} (${nametag})`);
            const playerMesh = new THREE.Mesh(new THREE.BoxGeometry(1, 1.8, 1), new THREE.MeshStandardMaterial({ color: 0xff0000 }));
            gameScene.add(playerMesh);

            let nametagMesh = null; // Initialize as null
            if (gameFont && gameScene) { // Ensure both scene and font are ready
                const textGeometry = new TextGeometry(nametag, { font: gameFont, size: 0.2, height: 0.02 });
                const textMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
                nametagMesh = new THREE.Mesh(textGeometry, textMaterial);
                nametagMesh.geometry.center();
                gameScene.add(nametagMesh);
            } else {
                console.warn(`[UI] gameFont not ready when creating player ${peerId}. Nametag will be missing.`);
            }

            players[peerId] = { mesh: playerMesh, nametagMesh: nametagMesh, nametag: nametag, position: new THREE.Vector3(), quaternion: new THREE.Quaternion() };
        }

        function handleDataReceived(event) {
            const { peerId, data } = event.detail;
            if (!data.type) return;
            if (data.type === 'state') {
                // This logic should be in game.js, but for now, we handle it here.
                // When state updates come in, find the corresponding player and update their position.
                // This is for remote players. The local player's position is handled by the physics engine.
                const player = players[peerId];
                if (player) {
                    player.position.copy(data.position);
                    player.quaternion.copy(data.quaternion);
                }
            } else if (data.type === 'shoot') {
                if (shootHandler) shootHandler(new THREE.Vector3().copy(data.direction), data.weapon);
            } else if (data.type === 'new-player') {
                if (!players[data.peerId]) {
                    createPlayer(data.peerId, data.nametag);
                }
            } else if (data.type === 'welcome') {
                // This is for the newly joined client
                showView(lobby);
                joinView.style.display = 'none';
                hostLobby.style.display = 'block';
                hostLobby.innerHTML = '<div class="text-center"><h2>Connected to Lobby</h2><p>Waiting for host to start the game...</p></div>';
                data.players.forEach(p => {
                    if (p.peerId !== getMyId() && !players[p.peerId]) {
                        createPlayer(p.peerId, p.nametag);
                    }
                });
            }
            else if (data.type === 'room-list') { // Received on connecting to matchmaking
                serverList = {};
                data.rooms.forEach(room => {
                    serverList[room.roomCode] = room.peerId;
                });
                updateServerListUI();
            } else if (data.type === 'new-room') { // Broadcast when a new room is created
                serverList[data.room.roomCode] = data.room.peerId;
                updateServerListUI();
            } else if (data.type === 'room-closed') { // Broadcast when a room is closed
                delete serverList[data.roomCode];
                updateServerListUI();
            } else if (data.type === 'player-list') { // Client receives this
                // This is for clients already in the game lobby when another joins/leaves
                dispatchNetworkEvent('player-list-updated', { players: data.players });
            }
            else if (data.type === 'start-game') {
                // This is for clients when the host starts the game
                dispatchNetworkEvent('game-started');
            } else if (data.type === 'player-left') {
                // This is for clients when another player leaves
                // The 'player-disconnected' event is already handled globally
                // but we might want to update the player list in the lobby if the game hasn't started.
                if (lobby.style.display === 'block' && !isHost) {
                    // A better approach is for the host to send an updated player list.
                }
            } else if (data.type === 'player-hit') {
                // This is received by the player who was hit
                if (data.targetId === getMyId()) {
                    // Find the player's body in game.js and apply damage
                    // This requires exporting the playerBody from game.js or a function to apply damage
                    console.log(`I've been hit by ${peerId} for ${data.damage} damage!`);
                    // Example: applyDamage(data.damage);
                }
            }
        }

        function setupGlobalNetworkListeners() {
            // --- Matchmaking Server Events ---
            window.addEventListener('matchmaking-connected', () => {
                showNetworkStatus('Connected to matchmaking service.');
            });

            window.addEventListener('matchmaking-error', (e) => {
                showNetworkStatus(e.detail.message, true);
            });

            window.addEventListener('matchmaking-disconnected', () => {
                showNetworkStatus('Disconnected from matchmaking service.', true);
            });

            window.addEventListener('game-hosted-success', (e) => {
                const { roomCode } = e.detail;
                if (isHost) {
                    hostIdDisplay.value = roomCode;
                }
            });

            window.addEventListener('host-peer-id-received', (e) => {
                const { peerId } = e.detail;
                if (peerId) {
                    showNetworkStatus(`Host found. Connecting...`);
                    connectToHost(peerId);
                } else {
                    showNetworkStatus('Could not find a game with that room code.', true);
                }
            });

            // --- PeerJS & P2P Connection Events ---
            window.addEventListener('peer-ready', (event) => {
                console.log('[UI] "peer-ready" event received.', event.detail);
                myPeerId = event.detail.peerId; // Store our ID
                // If we are already on the host screen, it means we were waiting for the peer ID.
                // Now we can request the room code.
                if (isHost && hostLobby.style.display === 'block') {
                    hostGame(myPeerId);
                }
            });

            window.addEventListener('connection-open', (event) => {
                console.log('[UI] "connection-open" event:', event.detail);
                showNetworkStatus(`Connected to ${event.detail.peerId}!`);
            });

            window.addEventListener('connection-error', (event) => {
                console.error('[UI] "connection-error" event:', event.detail);
                showNetworkStatus(`Error: ${event.detail.error.type || 'Connection failed'}`, true);
            });

            window.addEventListener('player-disconnected', (event) => {
                console.log('[UI] "player-disconnected" event:', event.detail);
                const { peerId } = event.detail;
                if (players[peerId] && players[peerId].nametagMesh && gameScene) {
                    gameScene.remove(players[peerId].nametagMesh);
                }
                if (players[peerId] && gameScene) {
                    gameScene.remove(players[peerId].mesh);
                    delete players[peerId];
                } else {
                    console.log(`Player ${peerId} not in game scene, but disconnected.`);
                }
                showNetworkStatus(`A player disconnected.`, true);
                if (isHost && lobby.style.display === 'block') {
                    // Host needs to update everyone's player list
                    const connections = getConnections();
                    const players = connections.map(c => ({ nametag: c.metadata.nametag })).concat({ nametag });
                    updatePlayerList(players);
                }
            });

            // --- Game Logic Events ---
            window.addEventListener('data-received', handleDataReceived);

            window.addEventListener('game-initialized', (e) => {
                gameScene = e.detail.scene;
                shootHandler = e.detail.handleShoot;
                gameFont = e.detail.font;
                console.log(`[UI] Game initialized. Processing ${playerCreateQueue.length} queued players.`);
                while (playerCreateQueue.length > 0) {
                    const playerData = playerCreateQueue.shift();
                    createPlayer(playerData.peerId, playerData.nametag);
                }
            });

            window.addEventListener('host-player-joined', (event) => {
                console.log('[UI] "host-player-joined" event:', event.detail);
            });

            window.addEventListener('player-list-updated', (event) => {
                console.log('[UI] "player-list-updated" event:', event.detail);
                updatePlayerList(event.detail.players);
                if (!isHost) startGameButton.style.display = 'none';
            });

            window.addEventListener('game-started', () => {
                console.log('[UI] "game-started" event received. Launching multiplayer game.');
                launchMultiplayerGame();
            });
        }


    </script>
</body>
</html>